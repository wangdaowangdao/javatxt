13.12 多线程(买票示例)
1.命令行中Ctrl+C用于停止程序
2.不同的线程会分配不同的堆和栈
3.多次启动一个线程是违法的
4.实现Runnable接口比较好用 

13.13 多线程（线程安全问题)
1. 因为CPU是随机在不同线程之间跳转的，所以一个线程在执行时不一定把一个线程任务完成再
去执行其他线程，所以有可能存在安全隐患。
2. 静态的方法可以通过类名直接调用。
3. 如果异常没法声明时，只能使用try-catch方法。
4. 多线程时一定要考虑安全问题。

13.14 线程安全问题产生的原因
1. 多个线程在操作共享的数据
2. 操作共享数据的线程代码有多条，
  当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问
题的产生。

13.15 多线程（同步代码块）
解决思路：
  就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程是不
参与运算。必须要当前线程把这些代码都执行完毕之后，其他线程才能参与运算。
  在java中，用同步代码块可以解决这个问题。
同步代码块的格式：
synchronized（对象）
{
需要被同步的代码;
}
 
13.16 多线程（同步的好处和弊端）

synchronized里面的对象相当于一个锁，也就是判断的标志位。
好处：解决了线程的安全问题
弊端：相对降低了效率，因为同步外的线程都会判断同步锁。

13.17 多线程（同步的前提）

同步的前提：必须有多个线程并使用同一个锁。

13.18 多线程（同步函数）
可以将synchronized加到需要同步的函数的修饰符，这种封装形式比较简单。

13.19 多线程（验证同步函数的锁）
1. 同步函数的锁是this
2. 同步函数和同步代码块的区别：
 同步函数的锁是this
 同步代码块的锁是任意的对象。

 建议使用同步代码块。

 13.20 多线程（静态同步函数的锁）
 静态同步函数的锁是该函数所属字节码文件对象，可以用getClass 方法获取，也可以用当前
 类名.Class表示。

 13.21 多线程（单例模式是涉及的多线程问题）
1. 单例模式：在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序
   对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干
   个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每
   台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时
   被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。
，分为懒汉式、饿汉式
2. 饿汉式会存在线程安全问题，同步函数会影响效率，一般使用同步块，采用双重检查，

（1）加入同步为了解决多线程安全问题。

（2）加入双重判断是为了解决效率问题。


静态同步函数的锁不是this。

13.22 多线程（死锁示例）
1. 死锁常见场景之一：同步的嵌套，有多个锁，实现同步的嵌套

13.23 多线程（线程间的通信）
线程间通信：多个线程在处理同一资源，但是任务却不同。
同步的前提：多个线程是否在同一个锁中。

13.24 多线程（线程间通信-等待唤醒机制）
等待/唤醒机制
涉及的方法：
1，wait();让线程处于冻结状态，被它线程被存储在线程池中。 wait（）方法和sleep（）方法
它们都能使得线程处于冻结状态。都能引发InterruptedException异常，必须进行抛出或者就行
处理，但是run（）方法中没有抛出异常，所以只能进行try{} ，catch（）{}处理。
2, notify();唤醒线程池中一个线程（任意）。
3, notifyAll();唤醒线程池中所有线程。

这些方法必须定义在同步中，这些方法用于操作线程状态，必须要明确
到底操作的是哪个锁上的线程。即在这些方法前面加“锁.方法”。

为什么操作线程的方法wait notify notifyAll定义在了Object类中？ 

因为这些方法是监视器的方法。监视器其实就是锁。
锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。
13.25 多线程（线程间通信-等待唤醒机制-代码优化）

类中的变量应该私有化，方法是public的来允许其他类对它们进行操作。

* 用一个词就可以描述注解，那就是元数据，又称中介数据、中继数据，即一种描述数据的数据，描述数据属性
的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。


14.32 多线程 wait和sleep的区别

1.wait可以指定时间也可以不指定时间
sleep必须指定时间

2,在同步中，对cpu的执行权和锁的处理不同
wait：释放执行权，释放锁
sleep：释放执行权，不释放锁

14.33 停止线程 定义标记
run 方法结束 定义停止线程的标记

14.34 停止线程 interrupt

如果线程进入了冻结状态，怎么结束线程呢？

  interrupt()方法将线程从冻结状态强制恢复到运行状态，让线程具备cpu执行资格，当使用
 强制动作发生时发生了InterruptedException,记得处理

 14.35 多线程 守护线程 -setDaemon
 t.setDaemon(true);该方法必须在线程启动之前设置；其他线程都结束了之后，守护线程会
 自动结束，而其他线程需要手动结束。

 守护线程可以理解为后台线程，当有程序依附于其他线程时，可以将它设置成守护线程。

 14.36 多线程 其他方法-join
 join() setPriority() toString() yield()

 /*
		 * 按照面向对象的思想对字符串进行功能分类。
		 * "abcd"
		 * 
		 * 1,获取：
		 * 1.1 获取字符串中字符的个数(长度).
		 * 		int length();
		 * 1.2 根据位置获取字符。
		 * 		char charAt(int index);
		 * 1.3 根据字符获取在字符串中的第一次出现的位置.
		 * 		int indexOf(int ch)
		 * 		int indexOf(int ch,int fromIndex):从指定位置进行ch的查找第一次出现位置 
		 * 		int indexOf(String str);
		 * 		int indexOf(String str,int fromIndex);
		 * 		 根据字符串获取在字符串中的第一次出现的位置.
		 * 		int lastIndexOf(int ch)
		 * 		int lastIndexOf(int ch,int fromIndex):从指定位置进行ch的查找第一次出现位置 
		 * 		int lastIndexOf(String str);
		 * 		int lastIndexOf(String str,int fromIndex);
		 * 1.4 获取字符串中一部分字符串。也叫子串.
		 * 		String substring(int beginIndex, int endIndex)//包含begin 不包含end 。
		 * 		String substring(int beginIndex);
		 * 		
		 * 
		 * 
		 * 2，转换。
		 * 		2.1 将字符串变成字符串数组(字符串的切割)
		 * 			String[]  split(String regex):涉及到正则表达式.
		 * 		2.2 将字符串变成字符数组。
		 * 			char[] toCharArray();
		 * 		2.3 将字符串变成字节数组。
		 * 			byte[] getBytes();
		 * 		2.4 将字符串中的字母转成大小写。
		 * 			String toUpperCase():大写
		 * 			String toLowerCase():小写
		 *		2.5  将字符串中的内容进行替换
		 *			String replace(char oldch,char newch);
		 * 			String replace(String s1,String s2);
		 * 		2.6 将字符串两端的空格去除。
		 * 			String trim();
		 * 		2.7 将字符串进行连接 。
		 * 			String concat(string);
		 * 
		 * 3，判断
		 * 		3.1 两个字符串内容是否相同啊？
		 * 			boolean equals(Object obj);
		 * 			boolean equalsIgnoreCase(string str);忽略大写比较字符串内容。
		 * 		3.2 字符串中是否包含指定字符串？
		 * 			boolean contains(string str);
		 * 		3.3 字符串是否以指定字符串开头。是否以指定字符串结尾。
		 * 			boolean startsWith(string);
		 * 			boolean endsWith(string);
		 * 		
		 * 4，比较。