13.12 多线程(买票示例)
1.命令行中Ctrl+C用于停止程序
2.不同的线程会分配不同的堆和栈
3.多次启动一个线程是违法的
4.实现Runnable接口比较好用 

13.13 多线程（线程安全问题)
1. 因为CPU是随机在不同线程之间跳转的，所以一个线程在执行时不一定把一个线程任务完成再
去执行其他线程，所以有可能存在安全隐患。
2. 静态的方法可以通过类名直接调用。
3. 如果异常没法声明时，只能使用try-catch方法。
4. 多线程时一定要考虑安全问题。

13.14 线程安全问题产生的原因
1. 多个线程在操作共享的数据
2. 操作共享数据的线程代码有多条，
  当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问
题的产生。

13.15 多线程（同步代码块）
解决思路：
  就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程是不
参与运算。必须要当前线程把这些代码都执行完毕之后，其他线程才能参与运算。
  在java中，用同步代码块可以解决这个问题。
同步代码块的格式：
synchronized（对象）
{
需要被同步的代码;
}
 
13.16 多线程（同步的好处和弊端）

synchronized里面的对象相当于一个锁，也就是判断的标志位。
好处：解决了线程的安全问题
弊端：相对降低了效率，因为同步外的线程都会判断同步锁。

13.17 多线程（同步的前提）

同步的前提：必须有多个线程并使用同一个锁。

13.18 多线程（同步函数）
可以将synchronized加到需要同步的函数的修饰符，这种封装形式比较简单。

13.19 多线程（验证同步函数的锁）
1. 同步函数的锁是this
2. 同步函数和同步代码块的区别：
 同步函数的锁是this
 同步代码块的锁是任意的对象。

 建议使用同步代码块。

 13.20 多线程（静态同步函数的锁）
 静态同步函数的锁是该函数所属字节码文件对象，可以用getClass 方法获取，也可以用当前
 类名.Class表示。

 13.21 多线程（单例模式是涉及的多线程问题）
1. 单例模式：在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序
   对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干
   个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每
   台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时
   被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。
，分为懒汉式、饿汉式
2. 饿汉式会存在线程安全问题，同步函数会影响效率，一般使用同步块，采用双重检查，

（1）加入同步为了解决多线程安全问题。

（2）加入双重判断是为了解决效率问题。


静态同步函数的锁不是this。

13.22 多线程（死锁示例）
1. 死锁常见场景之一：同步的嵌套，有多个锁，实现同步的嵌套

13.23 多线程（线程间的通信）
线程间通信：多个线程在处理同一资源，但是任务却不同。
同步的前提：多个线程是否在同一个锁中。

13.24 多线程（线程间通信-等待唤醒机制）
等待/唤醒机制
涉及的方法：
1，wait();让线程处于冻结状态，被它线程被存储在线程池中。 wait（）方法和sleep（）方法
它们都能使得线程处于冻结状态。都能引发InterruptedException异常，必须进行抛出或者就行
处理，但是run（）方法中没有抛出异常，所以只能进行try{} ，catch（）{}处理。
2, notify();唤醒线程池中一个线程（任意）。
3, notifyAll();唤醒线程池中所有线程。

这些方法必须定义在同步中，这些方法用于操作线程状态，必须要明确
到底操作的是哪个锁上的线程。即在这些方法前面加“锁.方法”。

为什么操作线程的方法wait notify notifyAll定义在了Object类中？ 

因为这些方法是监视器的方法。监视器其实就是锁。
锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中。