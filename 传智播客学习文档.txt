13.12 多线程(买票示例)
1.命令行中Ctrl+C用于停止程序
2.不同的线程会分配不同的堆和栈
3.多次启动一个线程是违法的
4.实现Runnable接口比较好用 

13.13 多线程（线程安全问题)
1. 因为CPU是随机在不同线程之间跳转的，所以一个线程在执行时不一定把一个线程任务完成再
去执行其他线程，所以有可能存在安全隐患。
2. 静态的方法可以通过类名直接调用。
3. 如果异常没法声明时，只能使用try-catch方法。
4. 多线程时一定要考虑安全问题。

13.14 线程安全问题产生的原因
1. 多个线程在操作共享的数据
2. 操作共享数据的线程代码有多条，
  当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问
题的产生。

13.15 多线程（同步代码块）
解决思路：
  就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程是不
参与运算。必须要当前线程把这些代码都执行完毕之后，其他线程才能参与运算。
  在java中，用同步代码块可以解决这个问题。
同步代码块的格式：
synchronized（对象）
{
需要被同步的代码;
}
 
13.16 多线程（同步的好处和弊端）

synchronized里面的对象相当于一个锁，也就是判断的标志位。
好处：解决了线程的安全问题
弊端：相对降低了效率，因为同步外的线程都会判断同步锁。

13.17 多线程（同步的前提）

同步的前提：必须有多个线程并使用同一个锁。

13.18 多线程（同步函数）
可以将synchronized加到需要同步的函数的修饰符，这种封装形式比较简单。

13.19 多线程（验证同步函数的锁）
1. 同步函数的锁是this
2. 同步函数和同步代码块的区别：
 同步函数的锁是this
 同步代码块的锁是任意的对象。

 建议使用同步代码块。

 13.20 多线程（静态同步函数的锁）
 静态同步函数的锁是该函数所属字节码文件对象，可以用getClass 方法获取，也可以用当前 类名.getClass表示。